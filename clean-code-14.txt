1) Было:
var requestQueue: [NetworkRequest]

Стало:
var requestQueue: Queue<NetworkRequest>

Ранее использовали массив для хранения порядка запросов, для выполнения их один за другим. Для этой цели лучше подходит структура Queue, так как не приходится вручную работать с индексами в массиве.

2) Было:
var currentNavigationStack: [UIViewController]

Стало:
var currentNavigationStack: Stack<UIViewController>

Для работы с текущим стэком экранов приложения раньше использовали массив. Для этой цели лучше подходит струкура данных стэк.

3) Было:
var analyticEvents: [AnalyticEvent]

Стало:
var analyticEvents: Set<AnalyticEvent>

Использовался массив отправленных событий в систему аналитики. При этом по бизнес-логике события должны быть уникальными, без дублей. При использовании массива перед каждой отправкой производился линейный поиск, что является неоптимальным решением. Решением было заменить массив на множество, так как порядок событий не важен, важна лишь проверка на дубли. Как результат - оптимизация скорости проверки и отсутствие работы с индексами массива.

4) Было:
var fileQueue: [FileData]

Стало:
var fileQueue: OrderedSet<FileData>

Использовался массив для очереди файлов, ожидающих скачивания с диска. При этом в массиве не должно быть дублей, так как если один файл уже находится в очереди, нет смысла скачивать его повторно. Решением было создать свою структуру данных OrderedSet, которая имеет порядок и при этом гарантирует отсутствие дублей.

5) Было:
var cache: [ImageData]

Стало:
var cache: [String: UIImage]

Для кэширования картинок из интернета использовался дисковый кэш в виде массива. Для поиска картинки нужно было пройтись по массиву, используя линейный поиск, и проверить наличие в структуре ImageData свойства url. Оптимизационным решением стало использования словаря для этой цели, в качестве ключа у которого ссылка, а значения - картинка.

