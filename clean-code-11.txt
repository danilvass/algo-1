1) var accountCount = 4 -> let accountCount = 4 // Изменена переменная на константу для небольшой логики.
2) var hasUpdates = false 
//...

hasUpdates = !isLoading && !promo.isEmpty //Переменная hasUpdates объявлялась в начале функции, и после некоторых вычислений ей присваивалось значение. 
//...

let hasUpdates = !isLoading && !promo.isEmpty //Теперь объявляем и заполняем ее сразу после этих вычислений.

3) userAccount = null //В завершающем методе работы с сессией пользователя, обнуляем ссылку на него, присваивая null.

4) assertionFailure(userInfo != null, "User Info not provided!") //В методах работы с пользователем, где мы должны быть уверены в его наличии, используем assertionFailure (конструкция языка, которая ломает приложение, если условие не исполняется. При этом ломает только Debug сборки, не затрагивая боевые версии.)

5) assertionFailure(paymentId != 0 || paymentId != 1) //В методах работы с платежной информацией, проверяем валидность некоторых данных с помощью assertionFailure

6) accountIndex = -1 //По окончанию работы со списком счетов, задачем невалидное значение переменной класса.

7) var cacheLimit = 1024 -> let CACHE_LIMIT = 24 //Изменили переменную на константу в кэше сообщений.

8) for (;;) {
	//
	count++
}

for (var count = transferList.count;; count++) //Убрали созданную заранее переменную, теперь создаем и храним внутри цикла

9) payAmount = -1 //Сбрасываем переменную после окончания работы с платежом.

10) var size = 10 -> let SIZE = 10 // Изменили переменную на константу для логики работы с фотографиями.

11) assertionFailure(Thread.isMainThread) //Проверка, что выполнение ведется на главном потоке

12) var isLoading = false 
//...
isLoading = response.count == 0 //Создавали переменную, после чего обрабатывали ответ от сервера, и обновляли ее значение.

//
let isLoading = response.count == 0 //Теперь сразу присваиваем значение переменное после получения ответа.